$OpenBSD: patch-source_i18n_regexcmp_cpp,v 1.2 2015/04/19 09:02:06 ajacoutot Exp $

CVE-2014-6585, CVE-2014-6591:
https://ssl.icu-project.org/trac/changeset/36724

CVE-2014-7923 CVE-2014-7926 CVE-2014-9654
https://ssl.icu-project.org/trac/changeset/36727
https://ssl.icu-project.org/trac/changeset/36801

--- source/i18n/regexcmp.cpp.orig	Sun Apr 19 10:22:55 2015
+++ source/i18n/regexcmp.cpp	Sun Apr 19 10:23:07 2015
@@ -301,7 +301,7 @@ void    RegexCompile::compile(
     //   present in the saved state:  the input string position (int64_t) and
     //   the position in the compiled pattern.
     //
-    fRXPat->fFrameSize+=RESTACKFRAME_HDRCOUNT;
+    allocateStackData(RESTACKFRAME_HDRCOUNT);
 
     //
     // Optimization pass 1: NOPs, back-references, and case-folding
@@ -367,9 +367,9 @@ UBool RegexCompile::doParseActions(int32_t action)
         //                    the start of an ( grouping.
         //4   NOP             Resreved, will be replaced by a save if there are
         //                    OR | operators at the top level
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_STATE_SAVE, 2), *fStatus);
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_JMP,  3), *fStatus);
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_FAIL, 0), *fStatus);
+        appendOp(URX_STATE_SAVE, 2);
+        appendOp(URX_JMP,  3);
+        appendOp(URX_FAIL, 0);
 
         // Standard open nonCapture paren action emits the two NOPs and
         //   sets up the paren stack frame.
@@ -392,7 +392,7 @@ UBool RegexCompile::doParseActions(int32_t action)
         }
 
         // add the END operation to the compiled pattern.
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_END, 0), *fStatus);
+        appendOp(URX_END, 0);
 
         // Terminate the pattern compilation state machine.
         returnVal = FALSE;
@@ -414,14 +414,13 @@ UBool RegexCompile::doParseActions(int32_t action)
             int32_t savePosition = fParenStack.popi();
             int32_t op = (int32_t)fRXPat->fCompiledPat->elementAti(savePosition);
             U_ASSERT(URX_TYPE(op) == URX_NOP);  // original contents of reserved location
-            op = URX_BUILD(URX_STATE_SAVE, fRXPat->fCompiledPat->size()+1);
+            op = buildOp(URX_STATE_SAVE, fRXPat->fCompiledPat->size()+1);
             fRXPat->fCompiledPat->setElementAt(op, savePosition);
 
             // Append an JMP operation into the compiled pattern.  The operand for
             //  the JMP will eventually be the location following the ')' for the
             //  group.  This will be patched in later, when the ')' is encountered.
-            op = URX_BUILD(URX_JMP, 0);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_JMP, 0);
 
             // Push the position of the newly added JMP op onto the parentheses stack.
             // This registers if for fixup when this block's close paren is encountered.
@@ -430,7 +429,7 @@ UBool RegexCompile::doParseActions(int32_t action)
             // Append a NOP to the compiled pattern.  This is the slot reserved
             //   for a SAVE in the event that there is yet another '|' following
             //   this one.
-            fRXPat->fCompiledPat->addElement(URX_BUILD(URX_NOP, 0), *fStatus);
+            appendOp(URX_NOP, 0);
             fParenStack.push(fRXPat->fCompiledPat->size()-1, *fStatus);
         }
         break;
@@ -456,12 +455,10 @@ UBool RegexCompile::doParseActions(int32_t action)
         //      END_CAPTURE is encountered.
         {
             fixLiterals();
-            fRXPat->fCompiledPat->addElement(URX_BUILD(URX_NOP, 0), *fStatus);
-            int32_t  varsLoc    = fRXPat->fFrameSize;    // Reserve three slots in match stack frame.
-            fRXPat->fFrameSize += 3;
-            int32_t  cop        = URX_BUILD(URX_START_CAPTURE, varsLoc);
-            fRXPat->fCompiledPat->addElement(cop, *fStatus);
-            fRXPat->fCompiledPat->addElement(URX_BUILD(URX_NOP, 0), *fStatus);
+            appendOp(URX_NOP, 0);
+            int32_t  varsLoc = allocateStackData(3);    // Reserve three slots in match stack frame.
+            appendOp(URX_START_CAPTURE, varsLoc);
+            appendOp(URX_NOP, 0);
 
             // On the Parentheses stack, start a new frame and add the postions
             //   of the two NOPs.  Depending on what follows in the pattern, the
@@ -486,8 +483,8 @@ UBool RegexCompile::doParseActions(int32_t action)
         //             is an '|' alternation within the parens.
         {
             fixLiterals();
-            fRXPat->fCompiledPat->addElement(URX_BUILD(URX_NOP, 0), *fStatus);
-            fRXPat->fCompiledPat->addElement(URX_BUILD(URX_NOP, 0), *fStatus);
+            appendOp(URX_NOP, 0);
+            appendOp(URX_NOP, 0);
 
             // On the Parentheses stack, start a new frame and add the postions
             //   of the two NOPs.
@@ -509,12 +506,10 @@ UBool RegexCompile::doParseActions(int32_t action)
         //             is an '|' alternation within the parens.
         {
             fixLiterals();
-            fRXPat->fCompiledPat->addElement(URX_BUILD(URX_NOP, 0), *fStatus);
-            int32_t  varLoc    = fRXPat->fDataSize;    // Reserve a data location for saving the
-            fRXPat->fDataSize += 1;                    //  state stack ptr.
-            int32_t  stoOp     = URX_BUILD(URX_STO_SP, varLoc);
-            fRXPat->fCompiledPat->addElement(stoOp, *fStatus);
-            fRXPat->fCompiledPat->addElement(URX_BUILD(URX_NOP, 0), *fStatus);
+            appendOp(URX_NOP, 0);
+            int32_t  varLoc = allocateData(1);    // Reserve a data location for saving the state stack ptr.
+            appendOp(URX_STO_SP, varLoc);
+            appendOp(URX_NOP, 0);
 
             // On the Parentheses stack, start a new frame and add the postions
             //   of the two NOPs.  Depending on what follows in the pattern, the
@@ -557,27 +552,15 @@ UBool RegexCompile::doParseActions(int32_t action)
         //  Two data slots are reserved, for saving the stack ptr and the input position.
         {
             fixLiterals();
-            int32_t dataLoc = fRXPat->fDataSize;
-            fRXPat->fDataSize += 2;
-            int32_t op = URX_BUILD(URX_LA_START, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            int32_t dataLoc = allocateData(2);
+            appendOp(URX_LA_START, dataLoc);
+            appendOp(URX_STATE_SAVE, fRXPat->fCompiledPat->size()+ 2);
+            appendOp(URX_JMP, fRXPat->fCompiledPat->size()+ 3);
+            appendOp(URX_LA_END, dataLoc);
+            appendOp(URX_BACKTRACK, 0);
+            appendOp(URX_NOP, 0);
+            appendOp(URX_NOP, 0);
 
-            op = URX_BUILD(URX_STATE_SAVE, fRXPat->fCompiledPat->size()+ 2);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-
-            op = URX_BUILD(URX_JMP, fRXPat->fCompiledPat->size()+ 3);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-
-            op = URX_BUILD(URX_LA_END, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-
-            op = URX_BUILD(URX_BACKTRACK, 0);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-
-            op = URX_BUILD(URX_NOP, 0);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-
             // On the Parentheses stack, start a new frame and add the postions
             //   of the NOPs.
             fParenStack.push(fModeFlags, *fStatus);                       // Match mode state
@@ -601,17 +584,11 @@ UBool RegexCompile::doParseActions(int32_t action)
         //                                        an alternate (transparent) region.
         {
             fixLiterals();
-            int32_t dataLoc = fRXPat->fDataSize;
-            fRXPat->fDataSize += 2;
-            int32_t op = URX_BUILD(URX_LA_START, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            int32_t dataLoc = allocateData(2);
+            appendOp(URX_LA_START, dataLoc);
+            appendOp(URX_STATE_SAVE, 0);    // dest address will be patched later.
+            appendOp(URX_NOP, 0);
 
-            op = URX_BUILD(URX_STATE_SAVE, 0);    // dest address will be patched later.
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-
-            op = URX_BUILD(URX_NOP, 0);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-
             // On the Parentheses stack, start a new frame and add the postions
             //   of the StateSave and NOP.
             fParenStack.push(fModeFlags, *fStatus);                       // Match mode state
@@ -648,23 +625,19 @@ UBool RegexCompile::doParseActions(int32_t action)
             fixLiterals();
 
             // Allocate data space
-            int32_t dataLoc = fRXPat->fDataSize;
-            fRXPat->fDataSize += 4;
+            int32_t dataLoc = allocateData(4);
 
             // Emit URX_LB_START
-            int32_t op = URX_BUILD(URX_LB_START, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LB_START, dataLoc);
 
             // Emit URX_LB_CONT
-            op = URX_BUILD(URX_LB_CONT, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-            fRXPat->fCompiledPat->addElement(0,  *fStatus);    // MinMatchLength.  To be filled later.
-            fRXPat->fCompiledPat->addElement(0,  *fStatus);    // MaxMatchLength.  To be filled later.
+            appendOp(URX_LB_CONT, dataLoc);
+            appendOp(URX_RESERVED_OP, 0);    // MinMatchLength.  To be filled later.
+            appendOp(URX_RESERVED_OP, 0);    // MaxMatchLength.  To be filled later.
 
-            // Emit the NOP
-            op = URX_BUILD(URX_NOP, 0);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            // Emit the NOPs
+            appendOp(URX_NOP, 0);
+            appendOp(URX_NOP, 0);
 
             // On the Parentheses stack, start a new frame and add the postions
             //   of the URX_LB_CONT and the NOP.
@@ -704,24 +677,20 @@ UBool RegexCompile::doParseActions(int32_t action)
             fixLiterals();
 
             // Allocate data space
-            int32_t dataLoc = fRXPat->fDataSize;
-            fRXPat->fDataSize += 4;
+            int32_t dataLoc = allocateData(4);
 
             // Emit URX_LB_START
-            int32_t op = URX_BUILD(URX_LB_START, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LB_START, dataLoc);
 
             // Emit URX_LBN_CONT
-            op = URX_BUILD(URX_LBN_CONT, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-            fRXPat->fCompiledPat->addElement(0,  *fStatus);    // MinMatchLength.  To be filled later.
-            fRXPat->fCompiledPat->addElement(0,  *fStatus);    // MaxMatchLength.  To be filled later.
-            fRXPat->fCompiledPat->addElement(0,  *fStatus);    // Continue Loc.    To be filled later.
+            appendOp(URX_LBN_CONT, dataLoc);
+            appendOp(URX_RESERVED_OP, 0);    // MinMatchLength.  To be filled later.
+            appendOp(URX_RESERVED_OP, 0);    // MaxMatchLength.  To be filled later.
+            appendOp(URX_RESERVED_OP, 0);    // Continue Loc.    To be filled later.
 
-            // Emit the NOP
-            op = URX_BUILD(URX_NOP, 0);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            // Emit the NOPs
+            appendOp(URX_NOP, 0);
+            appendOp(URX_NOP, 0);
 
             // On the Parentheses stack, start a new frame and add the postions
             //   of the URX_LB_CONT and the NOP.
@@ -791,12 +760,9 @@ UBool RegexCompile::doParseActions(int32_t action)
 
                 if (URX_TYPE(repeatedOp) == URX_SETREF) {
                     // Emit optimized code for [char set]+
-                    int32_t loopOpI = URX_BUILD(URX_LOOP_SR_I, URX_VAL(repeatedOp));
-                    fRXPat->fCompiledPat->addElement(loopOpI, *fStatus);
-                    frameLoc = fRXPat->fFrameSize;
-                    fRXPat->fFrameSize++;
-                    int32_t loopOpC = URX_BUILD(URX_LOOP_C, frameLoc);
-                    fRXPat->fCompiledPat->addElement(loopOpC, *fStatus);
+                    appendOp(URX_LOOP_SR_I, URX_VAL(repeatedOp));
+                    frameLoc = allocateStackData(1);
+                    appendOp(URX_LOOP_C, frameLoc);
                     break;
                 }
 
@@ -804,7 +770,7 @@ UBool RegexCompile::doParseActions(int32_t action)
                     URX_TYPE(repeatedOp) == URX_DOTANY_ALL ||
                     URX_TYPE(repeatedOp) == URX_DOTANY_UNIX) {
                     // Emit Optimized code for .+ operations.
-                    int32_t loopOpI = URX_BUILD(URX_LOOP_DOT_I, 0);
+                    int32_t loopOpI = buildOp(URX_LOOP_DOT_I, 0);
                     if (URX_TYPE(repeatedOp) == URX_DOTANY_ALL) {
                         // URX_LOOP_DOT_I operand is a flag indicating ". matches any" mode.
                         loopOpI |= 1;
@@ -812,11 +778,9 @@ UBool RegexCompile::doParseActions(int32_t action)
                     if (fModeFlags & UREGEX_UNIX_LINES) {
                         loopOpI |= 2;
                     }
-                    fRXPat->fCompiledPat->addElement(loopOpI, *fStatus);
-                    frameLoc = fRXPat->fFrameSize;
-                    fRXPat->fFrameSize++;
-                    int32_t loopOpC = URX_BUILD(URX_LOOP_C, frameLoc);
-                    fRXPat->fCompiledPat->addElement(loopOpC, *fStatus);
+                    appendOp(loopOpI);
+                    frameLoc = allocateStackData(1);
+                    appendOp(URX_LOOP_C, frameLoc);
                     break;
                 }
 
@@ -830,18 +794,15 @@ UBool RegexCompile::doParseActions(int32_t action)
                 // Zero length match is possible.
                 // Emit the code sequence that can handle it.
                 insertOp(topLoc);
-                frameLoc =  fRXPat->fFrameSize;
-                fRXPat->fFrameSize++;
+                frameLoc = allocateStackData(1);
 
-                int32_t op = URX_BUILD(URX_STO_INP_LOC, frameLoc);
+                int32_t op = buildOp(URX_STO_INP_LOC, frameLoc);
                 fRXPat->fCompiledPat->setElementAt(op, topLoc);
 
-                op = URX_BUILD(URX_JMP_SAV_X, topLoc+1);
-                fRXPat->fCompiledPat->addElement(op, *fStatus);
+                appendOp(URX_JMP_SAV_X, topLoc+1);
             } else {
                 // Simpler code when the repeated body must match something non-empty
-                int32_t  jmpOp  = URX_BUILD(URX_JMP_SAV, topLoc);
-                fRXPat->fCompiledPat->addElement(jmpOp, *fStatus);
+                appendOp(URX_JMP_SAV, topLoc);
             }
         }
         break;
@@ -853,8 +814,7 @@ UBool RegexCompile::doParseActions(int32_t action)
         //     3.   ...
         {
             int32_t topLoc      = blockTopLoc(FALSE);
-            int32_t saveStateOp = URX_BUILD(URX_STATE_SAVE, topLoc);
-            fRXPat->fCompiledPat->addElement(saveStateOp, *fStatus);
+            appendOp(URX_STATE_SAVE, topLoc);
         }
         break;
 
@@ -868,7 +828,7 @@ UBool RegexCompile::doParseActions(int32_t action)
         // Insert the state save into the compiled pattern, and we're done.
         {
             int32_t   saveStateLoc = blockTopLoc(TRUE);
-            int32_t   saveStateOp  = URX_BUILD(URX_STATE_SAVE, fRXPat->fCompiledPat->size());
+            int32_t   saveStateOp  = buildOp(URX_STATE_SAVE, fRXPat->fCompiledPat->size());
             fRXPat->fCompiledPat->setElementAt(saveStateOp, saveStateLoc);
         }
         break;
@@ -887,14 +847,12 @@ UBool RegexCompile::doParseActions(int32_t action)
             int32_t  jmp1_loc = blockTopLoc(TRUE);
             int32_t  jmp2_loc = fRXPat->fCompiledPat->size();
 
-            int32_t  jmp1_op  = URX_BUILD(URX_JMP, jmp2_loc+1);
+            int32_t  jmp1_op  = buildOp(URX_JMP, jmp2_loc+1);
             fRXPat->fCompiledPat->setElementAt(jmp1_op, jmp1_loc);
 
-            int32_t  jmp2_op  = URX_BUILD(URX_JMP, jmp2_loc+2);
-            fRXPat->fCompiledPat->addElement(jmp2_op, *fStatus);
+            appendOp(URX_JMP, jmp2_loc+2);
 
-            int32_t  save_op  = URX_BUILD(URX_STATE_SAVE, jmp1_loc+1);
-            fRXPat->fCompiledPat->addElement(save_op, *fStatus);
+            appendOp(URX_STATE_SAVE, jmp1_loc+1);
         }
         break;
 
@@ -934,12 +892,10 @@ UBool RegexCompile::doParseActions(int32_t action)
 
                 if (URX_TYPE(repeatedOp) == URX_SETREF) {
                     // Emit optimized code for a [char set]*
-                    int32_t loopOpI = URX_BUILD(URX_LOOP_SR_I, URX_VAL(repeatedOp));
+                    int32_t loopOpI = buildOp(URX_LOOP_SR_I, URX_VAL(repeatedOp));
                     fRXPat->fCompiledPat->setElementAt(loopOpI, topLoc);
-                    dataLoc = fRXPat->fFrameSize;
-                    fRXPat->fFrameSize++;
-                    int32_t loopOpC = URX_BUILD(URX_LOOP_C, dataLoc);
-                    fRXPat->fCompiledPat->addElement(loopOpC, *fStatus);
+                    dataLoc = allocateStackData(1);
+                    appendOp(URX_LOOP_C, dataLoc);
                     break;
                 }
 
@@ -947,7 +903,7 @@ UBool RegexCompile::doParseActions(int32_t action)
                     URX_TYPE(repeatedOp) == URX_DOTANY_ALL ||
                     URX_TYPE(repeatedOp) == URX_DOTANY_UNIX) {
                     // Emit Optimized code for .* operations.
-                    int32_t loopOpI = URX_BUILD(URX_LOOP_DOT_I, 0);
+                    int32_t loopOpI = buildOp(URX_LOOP_DOT_I, 0);
                     if (URX_TYPE(repeatedOp) == URX_DOTANY_ALL) {
                         // URX_LOOP_DOT_I operand is a flag indicating . matches any mode.
                         loopOpI |= 1;
@@ -956,10 +912,8 @@ UBool RegexCompile::doParseActions(int32_t action)
                         loopOpI |= 2;
                     }
                     fRXPat->fCompiledPat->setElementAt(loopOpI, topLoc);
-                    dataLoc = fRXPat->fFrameSize;
-                    fRXPat->fFrameSize++;
-                    int32_t loopOpC = URX_BUILD(URX_LOOP_C, dataLoc);
-                    fRXPat->fCompiledPat->addElement(loopOpC, *fStatus);
+                    dataLoc = allocateStackData(1);
+                    appendOp(URX_LOOP_C, dataLoc);
                     break;
                 }
             }
@@ -968,30 +922,29 @@ UBool RegexCompile::doParseActions(int32_t action)
             // The optimizations did not apply.
 
             int32_t   saveStateLoc = blockTopLoc(TRUE);
-            int32_t   jmpOp        = URX_BUILD(URX_JMP_SAV, saveStateLoc+1);
+            int32_t   jmpOp        = buildOp(URX_JMP_SAV, saveStateLoc+1);
 
             // Check for minimum match length of zero, which requires
             //    extra loop-breaking code.
             if (minMatchLength(saveStateLoc, fRXPat->fCompiledPat->size()-1) == 0) {
                 insertOp(saveStateLoc);
-                dataLoc =  fRXPat->fFrameSize;
-                fRXPat->fFrameSize++;
+                dataLoc = allocateStackData(1);
 
-                int32_t op = URX_BUILD(URX_STO_INP_LOC, dataLoc);
+                int32_t op = buildOp(URX_STO_INP_LOC, dataLoc);
                 fRXPat->fCompiledPat->setElementAt(op, saveStateLoc+1);
-                jmpOp      = URX_BUILD(URX_JMP_SAV_X, saveStateLoc+2);
+                jmpOp      = buildOp(URX_JMP_SAV_X, saveStateLoc+2);
             }
 
             // Locate the position in the compiled pattern where the match will continue
             //   after completing the *.   (4 or 5 in the comment above)
             int32_t continueLoc = fRXPat->fCompiledPat->size()+1;
 
-            // Put together the save state op store it into the compiled code.
-            int32_t saveStateOp = URX_BUILD(URX_STATE_SAVE, continueLoc);
+            // Put together the save state op and store it into the compiled code.
+            int32_t saveStateOp = buildOp(URX_STATE_SAVE, continueLoc);
             fRXPat->fCompiledPat->setElementAt(saveStateOp, saveStateLoc);
 
             // Append the URX_JMP_SAV or URX_JMPX operation to the compiled pattern.
-            fRXPat->fCompiledPat->addElement(jmpOp, *fStatus);
+            appendOp(jmpOp);
         }
         break;
 
@@ -1005,10 +958,9 @@ UBool RegexCompile::doParseActions(int32_t action)
         {
             int32_t     jmpLoc  = blockTopLoc(TRUE);                   // loc  1.
             int32_t     saveLoc = fRXPat->fCompiledPat->size();        // loc  3.
-            int32_t     jmpOp   = URX_BUILD(URX_JMP, saveLoc);
-            int32_t     stateSaveOp = URX_BUILD(URX_STATE_SAVE, jmpLoc+1);
+            int32_t     jmpOp   = buildOp(URX_JMP, saveLoc);
             fRXPat->fCompiledPat->setElementAt(jmpOp, jmpLoc);
-            fRXPat->fCompiledPat->addElement(stateSaveOp, *fStatus);
+            appendOp(URX_STATE_SAVE, jmpLoc+1);
         }
         break;
 
@@ -1077,9 +1029,9 @@ UBool RegexCompile::doParseActions(int32_t action)
 
             // First the STO_SP before the start of the loop
             insertOp(topLoc);
-            int32_t  varLoc    = fRXPat->fDataSize;    // Reserve a data location for saving the
-            fRXPat->fDataSize += 1;                    //  state stack ptr.
-            int32_t  op        = URX_BUILD(URX_STO_SP, varLoc);
+
+            int32_t  varLoc = allocateData(1);   // Reserve a data location for saving the
+            int32_t  op     = buildOp(URX_STO_SP, varLoc);
             fRXPat->fCompiledPat->setElementAt(op, topLoc);
 
             int32_t loopOp = (int32_t)fRXPat->fCompiledPat->popi();
@@ -1088,8 +1040,7 @@ UBool RegexCompile::doParseActions(int32_t action)
             fRXPat->fCompiledPat->push(loopOp, *fStatus);
 
             // Then the LD_SP after the end of the loop
-            op = URX_BUILD(URX_LD_SP, varLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LD_SP, varLoc);
         }
 
         break;
@@ -1125,55 +1076,49 @@ UBool RegexCompile::doParseActions(int32_t action)
         // scanned a ".",  match any single character.
         {
             fixLiterals(FALSE);
-            int32_t   op;
             if (fModeFlags & UREGEX_DOTALL) {
-                op = URX_BUILD(URX_DOTANY_ALL, 0);
+                appendOp(URX_DOTANY_ALL, 0);
             } else if (fModeFlags & UREGEX_UNIX_LINES) {
-                op = URX_BUILD(URX_DOTANY_UNIX, 0);
+                appendOp(URX_DOTANY_UNIX, 0);
             } else {
-                op = URX_BUILD(URX_DOTANY, 0);
+                appendOp(URX_DOTANY, 0);
             }
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
         }
         break;
 
     case doCaret:
         {
             fixLiterals(FALSE);
-            int32_t op = 0;
             if (       (fModeFlags & UREGEX_MULTILINE) == 0 && (fModeFlags & UREGEX_UNIX_LINES) == 0) {
-                op = URX_CARET;
+                appendOp(URX_CARET, 0);
             } else if ((fModeFlags & UREGEX_MULTILINE) != 0 && (fModeFlags & UREGEX_UNIX_LINES) == 0) {
-                op = URX_CARET_M;
+                appendOp(URX_CARET_M, 0);
             } else if ((fModeFlags & UREGEX_MULTILINE) == 0 && (fModeFlags & UREGEX_UNIX_LINES) != 0) {
-                op = URX_CARET;   // Only testing true start of input.
+                appendOp(URX_CARET, 0);   // Only testing true start of input.
             } else if ((fModeFlags & UREGEX_MULTILINE) != 0 && (fModeFlags & UREGEX_UNIX_LINES) != 0) {
-                op = URX_CARET_M_UNIX;
+                appendOp(URX_CARET_M_UNIX, 0);
             }
-            fRXPat->fCompiledPat->addElement(URX_BUILD(op, 0), *fStatus);
         }
         break;
 
     case doDollar:
         {
             fixLiterals(FALSE);
-            int32_t op = 0;
             if (       (fModeFlags & UREGEX_MULTILINE) == 0 && (fModeFlags & UREGEX_UNIX_LINES) == 0) {
-                op = URX_DOLLAR;
+                appendOp(URX_DOLLAR, 0);
             } else if ((fModeFlags & UREGEX_MULTILINE) != 0 && (fModeFlags & UREGEX_UNIX_LINES) == 0) {
-                op = URX_DOLLAR_M;
+                appendOp(URX_DOLLAR_M, 0);
             } else if ((fModeFlags & UREGEX_MULTILINE) == 0 && (fModeFlags & UREGEX_UNIX_LINES) != 0) {
-                op = URX_DOLLAR_D;
+                appendOp(URX_DOLLAR_D, 0);
             } else if ((fModeFlags & UREGEX_MULTILINE) != 0 && (fModeFlags & UREGEX_UNIX_LINES) != 0) {
-                op = URX_DOLLAR_MD;
+                appendOp(URX_DOLLAR_MD, 0);
             }
-            fRXPat->fCompiledPat->addElement(URX_BUILD(op, 0), *fStatus);
         }
         break;
 
     case doBackslashA:
         fixLiterals(FALSE);
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_CARET, 0), *fStatus);
+        appendOp(URX_CARET, 0);
         break;
 
     case doBackslashB:
@@ -1185,7 +1130,7 @@ UBool RegexCompile::doParseActions(int32_t action)
             #endif
             fixLiterals(FALSE);
             int32_t op = (fModeFlags & UREGEX_UWORD)? URX_BACKSLASH_BU : URX_BACKSLASH_B;
-            fRXPat->fCompiledPat->addElement(URX_BUILD(op, 1), *fStatus);
+            appendOp(op, 1);
         }
         break;
 
@@ -1198,63 +1143,59 @@ UBool RegexCompile::doParseActions(int32_t action)
             #endif
             fixLiterals(FALSE);
             int32_t op = (fModeFlags & UREGEX_UWORD)? URX_BACKSLASH_BU : URX_BACKSLASH_B;
-            fRXPat->fCompiledPat->addElement(URX_BUILD(op, 0), *fStatus);
+            appendOp(op, 0);
         }
         break;
 
     case doBackslashD:
         fixLiterals(FALSE);
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_BACKSLASH_D, 1), *fStatus);
+        appendOp(URX_BACKSLASH_D, 1);
         break;
 
     case doBackslashd:
         fixLiterals(FALSE);
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_BACKSLASH_D, 0), *fStatus);
+        appendOp(URX_BACKSLASH_D, 0);
         break;
 
     case doBackslashG:
         fixLiterals(FALSE);
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_BACKSLASH_G, 0), *fStatus);
+        appendOp(URX_BACKSLASH_G, 0);
         break;
 
     case doBackslashS:
         fixLiterals(FALSE);
-        fRXPat->fCompiledPat->addElement(
-            URX_BUILD(URX_STAT_SETREF_N, URX_ISSPACE_SET), *fStatus);
+        appendOp(URX_STAT_SETREF_N, URX_ISSPACE_SET);
         break;
 
     case doBackslashs:
         fixLiterals(FALSE);
-        fRXPat->fCompiledPat->addElement(
-            URX_BUILD(URX_STATIC_SETREF, URX_ISSPACE_SET), *fStatus);
+        appendOp(URX_STATIC_SETREF, URX_ISSPACE_SET);
         break;
 
     case doBackslashW:
         fixLiterals(FALSE);
-        fRXPat->fCompiledPat->addElement(
-            URX_BUILD(URX_STAT_SETREF_N, URX_ISWORD_SET), *fStatus);
+        appendOp(URX_STAT_SETREF_N, URX_ISWORD_SET);
         break;
 
     case doBackslashw:
         fixLiterals(FALSE);
-        fRXPat->fCompiledPat->addElement(
-            URX_BUILD(URX_STATIC_SETREF, URX_ISWORD_SET), *fStatus);
+        appendOp(URX_STATIC_SETREF, URX_ISWORD_SET);
         break;
 
     case doBackslashX:
         fixLiterals(FALSE);
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_BACKSLASH_X, 0), *fStatus);
+        appendOp(URX_BACKSLASH_X, 0);
         break;
 
 
     case doBackslashZ:
         fixLiterals(FALSE);
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_DOLLAR, 0), *fStatus);
+        appendOp(URX_DOLLAR, 0);
         break;
 
     case doBackslashz:
         fixLiterals(FALSE);
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_BACKSLASH_Z, 0), *fStatus);
+        appendOp(URX_BACKSLASH_Z, 0);
         break;
 
     case doEscapeError:
@@ -1314,13 +1255,11 @@ UBool RegexCompile::doParseActions(int32_t action)
             U_ASSERT(groupNum > 0);  // Shouldn't happen.  '\0' begins an octal escape sequence,
                                      //    and shouldn't enter this code path at all.
             fixLiterals(FALSE);
-            int32_t  op;
             if (fModeFlags & UREGEX_CASE_INSENSITIVE) {
-                op = URX_BUILD(URX_BACKREF_I, groupNum);
+                appendOp(URX_BACKREF_I, groupNum);
             } else {
-                op = URX_BUILD(URX_BACKREF, groupNum);
+                appendOp(URX_BACKREF, groupNum);
             }
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
         }
         break;
 
@@ -1341,22 +1280,18 @@ UBool RegexCompile::doParseActions(int32_t action)
         {
             // Emit the STO_SP
             int32_t   topLoc = blockTopLoc(TRUE);
-            int32_t   stoLoc = fRXPat->fDataSize;
-            fRXPat->fDataSize++;       // Reserve the data location for storing save stack ptr.
-            int32_t   op     = URX_BUILD(URX_STO_SP, stoLoc);
+            int32_t   stoLoc = allocateData(1);  // Reserve the data location for storing save stack ptr.
+            int32_t   op     = buildOp(URX_STO_SP, stoLoc);
             fRXPat->fCompiledPat->setElementAt(op, topLoc);
 
             // Emit the STATE_SAVE
-            op = URX_BUILD(URX_STATE_SAVE, fRXPat->fCompiledPat->size()+2);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_STATE_SAVE, fRXPat->fCompiledPat->size()+2);
 
             // Emit the JMP
-            op = URX_BUILD(URX_JMP, topLoc+1);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_JMP, topLoc+1);
 
             // Emit the LD_SP
-            op = URX_BUILD(URX_LD_SP, stoLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LD_SP, stoLoc);
         }
         break;
 
@@ -1376,23 +1311,20 @@ UBool RegexCompile::doParseActions(int32_t action)
             insertOp(topLoc);
 
             // emit   STO_SP     loc
-            int32_t   stoLoc = fRXPat->fDataSize;
-            fRXPat->fDataSize++;       // Reserve the data location for storing save stack ptr.
-            int32_t   op     = URX_BUILD(URX_STO_SP, stoLoc);
+            int32_t   stoLoc = allocateData(1);    // Reserve the data location for storing save stack ptr.
+            int32_t   op     = buildOp(URX_STO_SP, stoLoc);
             fRXPat->fCompiledPat->setElementAt(op, topLoc);
 
             // Emit the SAVE_STATE   5
             int32_t L7 = fRXPat->fCompiledPat->size()+1;
-            op = URX_BUILD(URX_STATE_SAVE, L7);
+            op = buildOp(URX_STATE_SAVE, L7);
             fRXPat->fCompiledPat->setElementAt(op, topLoc+1);
 
             // Append the JMP operation.
-            op = URX_BUILD(URX_JMP, topLoc+1);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_JMP, topLoc+1);
 
             // Emit the LD_SP       loc
-            op = URX_BUILD(URX_LD_SP, stoLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LD_SP, stoLoc);
         }
         break;
 
@@ -1411,19 +1343,17 @@ UBool RegexCompile::doParseActions(int32_t action)
             insertOp(topLoc);
 
             // Emit the STO_SP
-            int32_t   stoLoc = fRXPat->fDataSize;
-            fRXPat->fDataSize++;       // Reserve the data location for storing save stack ptr.
-            int32_t   op     = URX_BUILD(URX_STO_SP, stoLoc);
+            int32_t   stoLoc = allocateData(1);   // Reserve the data location for storing save stack ptr.
+            int32_t   op     = buildOp(URX_STO_SP, stoLoc);
             fRXPat->fCompiledPat->setElementAt(op, topLoc);
 
             // Emit the SAVE_STATE
             int32_t   continueLoc = fRXPat->fCompiledPat->size()+1;
-            op = URX_BUILD(URX_STATE_SAVE, continueLoc);
+            op = buildOp(URX_STATE_SAVE, continueLoc);
             fRXPat->fCompiledPat->setElementAt(op, topLoc+1);
 
             // Emit the LD_SP
-            op = URX_BUILD(URX_LD_SP, stoLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LD_SP, stoLoc);
         }
         break;
 
@@ -1480,8 +1410,8 @@ UBool RegexCompile::doParseActions(int32_t action)
         //             is an '|' alternation within the parens.
         {
             fixLiterals(FALSE);
-            fRXPat->fCompiledPat->addElement(URX_BUILD(URX_NOP, 0), *fStatus);
-            fRXPat->fCompiledPat->addElement(URX_BUILD(URX_NOP, 0), *fStatus);
+            appendOp(URX_NOP, 0);
+            appendOp(URX_NOP, 0);
 
             // On the Parentheses stack, start a new frame and add the postions
             //   of the two NOPs (a normal non-capturing () frame, except for the
@@ -1818,7 +1748,6 @@ void RegexCompile::literalChar(UChar32 c)  {
 //
 //------------------------------------------------------------------------------
 void    RegexCompile::fixLiterals(UBool split) {
-    int32_t  op = 0;                       // An op from/for the compiled pattern.
 
     // If no literal characters have been scanned but not yet had code generated
     //   for them, nothing needs to be done.
@@ -1857,23 +1786,23 @@ void    RegexCompile::fixLiterals(UBool split) {
         // Single character, emit a URX_ONECHAR op to match it.
         if ((fModeFlags & UREGEX_CASE_INSENSITIVE) &&
                  u_hasBinaryProperty(lastCodePoint, UCHAR_CASE_SENSITIVE)) {
-            op = URX_BUILD(URX_ONECHAR_I, lastCodePoint);
+            appendOp(URX_ONECHAR_I, lastCodePoint);
         } else {
-            op = URX_BUILD(URX_ONECHAR, lastCodePoint);
+            appendOp(URX_ONECHAR, lastCodePoint);
         }
-        fRXPat->fCompiledPat->addElement(op, *fStatus);
     } else {
         // Two or more chars, emit a URX_STRING to match them.
+        if (fLiteralChars.length() > 0x00ffffff || fRXPat->fLiteralText.length() > 0x00ffffff) {
+            error(U_REGEX_PATTERN_TOO_BIG);
+        }
         if (fModeFlags & UREGEX_CASE_INSENSITIVE) {
-            op = URX_BUILD(URX_STRING_I, fRXPat->fLiteralText.length());
+            appendOp(URX_STRING_I, fRXPat->fLiteralText.length());
         } else {
             // TODO here:  add optimization to split case sensitive strings of length two
             //             into two single char ops, for efficiency.
-            op = URX_BUILD(URX_STRING, fRXPat->fLiteralText.length());
+            appendOp(URX_STRING, fRXPat->fLiteralText.length());
         }
-        fRXPat->fCompiledPat->addElement(op, *fStatus);
-        op = URX_BUILD(URX_STRING_LEN, fLiteralChars.length());
-        fRXPat->fCompiledPat->addElement(op, *fStatus);
+        appendOp(URX_STRING_LEN, fLiteralChars.length());
 
         // Add this string into the accumulated strings of the compiled pattern.
         fRXPat->fLiteralText.append(fLiteralChars);
@@ -1883,10 +1812,60 @@ void    RegexCompile::fixLiterals(UBool split) {
 }
 
 
+int32_t RegexCompile::buildOp(int32_t type, int32_t val) {
+    if (U_FAILURE(*fStatus)) {
+        return 0;
+    }
+    if (type < 0 || type > 255) {
+        U_ASSERT(FALSE);
+        error(U_REGEX_INTERNAL_ERROR);
+        type = URX_RESERVED_OP;
+    }
+    if (val > 0x00ffffff) {
+        U_ASSERT(FALSE);
+        error(U_REGEX_INTERNAL_ERROR);
+        val = 0;
+    }
+    if (val < 0) {
+        if (!(type == URX_RESERVED_OP_N || type == URX_RESERVED_OP)) {
+            U_ASSERT(FALSE);
+            error(U_REGEX_INTERNAL_ERROR);
+            return -1;
+        }
+        if (URX_TYPE(val) != 0xff) {
+            U_ASSERT(FALSE);
+            error(U_REGEX_INTERNAL_ERROR);
+            return -1;
+        }
+        type = URX_RESERVED_OP_N;
+    }
+    return (type << 24) | val;
+}
 
 
+//------------------------------------------------------------------------------
+//
+//   appendOp()             Append a new instruction onto the compiled pattern
+//                          Includes error checking, limiting the size of the
+//                          pattern to lengths that can be represented in the
+//                          24 bit operand field of an instruction.
+//
+//------------------------------------------------------------------------------
+void RegexCompile::appendOp(int32_t op) {
+    if (U_FAILURE(*fStatus)) {
+        return;
+    }
+    fRXPat->fCompiledPat->addElement(op, *fStatus);
+    if ((fRXPat->fCompiledPat->size() > 0x00fffff0) && U_SUCCESS(*fStatus)) {
+        error(U_REGEX_PATTERN_TOO_BIG);
+    }
+}
 
+void RegexCompile::appendOp(int32_t type, int32_t val) {
+    appendOp(buildOp(type, val));
+}
 
+
 //------------------------------------------------------------------------------
 //
 //   insertOp()             Insert a slot for a new opcode into the already
@@ -1900,7 +1879,7 @@ void   RegexCompile::insertOp(int32_t where) {
     UVector64 *code = fRXPat->fCompiledPat;
     U_ASSERT(where>0 && where < code->size());
 
-    int32_t  nop = URX_BUILD(URX_NOP, 0);
+    int32_t  nop = buildOp(URX_NOP, 0);
     code->insertElementAt(nop, where, *fStatus);
 
     // Walk through the pattern, looking for any ops with targets that
@@ -1921,7 +1900,7 @@ void   RegexCompile::insertOp(int32_t where) {
             // Target location for this opcode is after the insertion point and
             //   needs to be incremented to adjust for the insertion.
             opValue++;
-            op = URX_BUILD(opType, opValue);
+            op = buildOp(opType, opValue);
             code->setElementAt(op, loc);
         }
     }
@@ -1946,9 +1925,61 @@ void   RegexCompile::insertOp(int32_t where) {
 }
 
 
+//------------------------------------------------------------------------------
+//
+//   allocateData()        Allocate storage in the matcher's static data area.
+//                         Return the index for the newly allocated data.
+//                         The storage won't actually exist until we are running a match
+//                         operation, but the storage indexes are inserted into various
+//                         opcodes while compiling the pattern.
+//
+//------------------------------------------------------------------------------
+int32_t RegexCompile::allocateData(int32_t size) {
+    if (U_FAILURE(*fStatus)) {
+        return 0;
+    }
+    if (size <= 0 || size > 0x100 || fRXPat->fDataSize < 0) {
+        error(U_REGEX_INTERNAL_ERROR);
+        return 0;
+    }
+    int32_t dataIndex = fRXPat->fDataSize;
+    fRXPat->fDataSize += size;
+    if (fRXPat->fDataSize >= 0x00fffff0) {
+        error(U_REGEX_INTERNAL_ERROR);
+    }
+    return dataIndex;
+}
 
+
 //------------------------------------------------------------------------------
 //
+//   allocateStackData()   Allocate space in the back-tracking stack frame.
+//                         Return the index for the newly allocated data.
+//                         The frame indexes are inserted into various
+//                         opcodes while compiling the pattern, meaning that frame
+//                         size must be restricted to the size that will fit
+//                         as an operand (24 bits).
+//
+//------------------------------------------------------------------------------
+int32_t RegexCompile::allocateStackData(int32_t size) {
+    if (U_FAILURE(*fStatus)) {
+        return 0;
+    }
+    if (size <= 0 || size > 0x100 || fRXPat->fFrameSize < 0) {
+        error(U_REGEX_INTERNAL_ERROR);
+        return 0;
+    }
+    int32_t dataIndex = fRXPat->fFrameSize;
+    fRXPat->fFrameSize += size;
+    if (fRXPat->fFrameSize >= 0x00fffff0) {
+        error(U_REGEX_PATTERN_TOO_BIG);
+    }
+    return dataIndex;
+}
+
+
+//------------------------------------------------------------------------------
+//
 //   blockTopLoc()          Find or create a location in the compiled pattern
 //                          at the start of the operation or block that has
 //                          just been compiled.  Needed when a quantifier (* or
@@ -1988,7 +2019,7 @@ int32_t   RegexCompile::blockTopLoc(UBool reserveLoc) 
             theLoc--;
         }
         if (reserveLoc) {
-            int32_t  nop = URX_BUILD(URX_NOP, 0);
+            int32_t  nop = buildOp(URX_NOP, 0);
             fRXPat->fCompiledPat->insertElementAt(nop, theLoc, *fStatus);
         }
     }
@@ -2063,8 +2094,7 @@ void  RegexCompile::handleCloseParen() {
             U_ASSERT(URX_TYPE(captureOp) == URX_START_CAPTURE);
 
             int32_t   frameVarLocation = URX_VAL(captureOp);
-            int32_t   endCaptureOp = URX_BUILD(URX_END_CAPTURE, frameVarLocation);
-            fRXPat->fCompiledPat->addElement(endCaptureOp, *fStatus);
+            appendOp(URX_END_CAPTURE, frameVarLocation);
         }
         break;
     case atomic:
@@ -2075,8 +2105,7 @@ void  RegexCompile::handleCloseParen() {
             int32_t   stoOp = (int32_t)fRXPat->fCompiledPat->elementAti(fMatchOpenParen+1);
             U_ASSERT(URX_TYPE(stoOp) == URX_STO_SP);
             int32_t   stoLoc = URX_VAL(stoOp);
-            int32_t   ldOp   = URX_BUILD(URX_LD_SP, stoLoc);
-            fRXPat->fCompiledPat->addElement(ldOp, *fStatus);
+            appendOp(URX_LD_SP, stoLoc);
         }
         break;
 
@@ -2085,8 +2114,7 @@ void  RegexCompile::handleCloseParen() {
             int32_t  startOp = (int32_t)fRXPat->fCompiledPat->elementAti(fMatchOpenParen-5);
             U_ASSERT(URX_TYPE(startOp) == URX_LA_START);
             int32_t dataLoc  = URX_VAL(startOp);
-            int32_t op       = URX_BUILD(URX_LA_END, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LA_END, dataLoc);
         }
         break;
 
@@ -2096,19 +2124,16 @@ void  RegexCompile::handleCloseParen() {
             int32_t  startOp = (int32_t)fRXPat->fCompiledPat->elementAti(fMatchOpenParen-1);
             U_ASSERT(URX_TYPE(startOp) == URX_LA_START);
             int32_t dataLoc  = URX_VAL(startOp);
-            int32_t op       = URX_BUILD(URX_LA_END, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-            op               = URX_BUILD(URX_BACKTRACK, 0);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-            op               = URX_BUILD(URX_LA_END, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LA_END, dataLoc);
+            appendOp(URX_BACKTRACK, 0);
+            appendOp(URX_LA_END, dataLoc);
 
             // Patch the URX_SAVE near the top of the block.
             // The destination of the SAVE is the final LA_END that was just added.
             int32_t saveOp   = (int32_t)fRXPat->fCompiledPat->elementAti(fMatchOpenParen);
             U_ASSERT(URX_TYPE(saveOp) == URX_STATE_SAVE);
             int32_t dest     = fRXPat->fCompiledPat->size()-1;
-            saveOp           = URX_BUILD(URX_STATE_SAVE, dest);
+            saveOp           = buildOp(URX_STATE_SAVE, dest);
             fRXPat->fCompiledPat->setElementAt(saveOp, fMatchOpenParen);
         }
         break;
@@ -2121,10 +2146,8 @@ void  RegexCompile::handleCloseParen() {
             int32_t  startOp = (int32_t)fRXPat->fCompiledPat->elementAti(fMatchOpenParen-4);
             U_ASSERT(URX_TYPE(startOp) == URX_LB_START);
             int32_t dataLoc  = URX_VAL(startOp);
-            int32_t op       = URX_BUILD(URX_LB_END, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-                    op       = URX_BUILD(URX_LA_END, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LB_END, dataLoc);
+            appendOp(URX_LA_END, dataLoc);
 
             // Determine the min and max bounds for the length of the
             //  string that the pattern can match.
@@ -2132,6 +2155,10 @@ void  RegexCompile::handleCloseParen() {
             int32_t patEnd   = fRXPat->fCompiledPat->size() - 1;
             int32_t minML    = minMatchLength(fMatchOpenParen, patEnd);
             int32_t maxML    = maxMatchLength(fMatchOpenParen, patEnd);
+            if (URX_TYPE(maxML) != 0) {
+                error(U_REGEX_LOOK_BEHIND_LIMIT);
+                break;
+            }
             if (maxML == INT32_MAX) {
                 error(U_REGEX_LOOK_BEHIND_LIMIT);
                 break;
@@ -2156,8 +2183,7 @@ void  RegexCompile::handleCloseParen() {
             int32_t  startOp = (int32_t)fRXPat->fCompiledPat->elementAti(fMatchOpenParen-5);
             U_ASSERT(URX_TYPE(startOp) == URX_LB_START);
             int32_t dataLoc  = URX_VAL(startOp);
-            int32_t op       = URX_BUILD(URX_LBN_END, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LBN_END, dataLoc);
 
             // Determine the min and max bounds for the length of the
             //  string that the pattern can match.
@@ -2165,6 +2191,10 @@ void  RegexCompile::handleCloseParen() {
             int32_t patEnd   = fRXPat->fCompiledPat->size() - 1;
             int32_t minML    = minMatchLength(fMatchOpenParen, patEnd);
             int32_t maxML    = maxMatchLength(fMatchOpenParen, patEnd);
+            if (URX_TYPE(maxML) != 0) {
+                error(U_REGEX_LOOK_BEHIND_LIMIT);
+                break;
+            }
             if (maxML == INT32_MAX) {
                 error(U_REGEX_LOOK_BEHIND_LIMIT);
                 break;
@@ -2178,7 +2208,7 @@ void  RegexCompile::handleCloseParen() {
 
             // Insert the pattern location to continue at after a successful match
             //  as the last operand of the URX_LBN_CONT
-            op = URX_BUILD(URX_RELOC_OPRND, fRXPat->fCompiledPat->size());
+            int32_t op = buildOp(URX_RELOC_OPRND, fRXPat->fCompiledPat->size());
             fRXPat->fCompiledPat->setElementAt(op,  fMatchOpenParen-1);
         }
         break;
@@ -2219,7 +2249,7 @@ void        RegexCompile::compileSet(UnicodeSet *theSe
     case 0:
         {
             // Set of no elements.   Always fails to match.
-            fRXPat->fCompiledPat->addElement(URX_BUILD(URX_BACKTRACK, 0), *fStatus);
+            appendOp(URX_BACKTRACK, 0);
             delete theSet;
         }
         break;
@@ -2240,8 +2270,7 @@ void        RegexCompile::compileSet(UnicodeSet *theSe
             //  Put it into the compiled pattern as a set.
             int32_t setNumber = fRXPat->fSets->size();
             fRXPat->fSets->addElement(theSet, *fStatus);
-            int32_t setOp = URX_BUILD(URX_SETREF, setNumber);
-            fRXPat->fCompiledPat->addElement(setOp, *fStatus);
+            appendOp(URX_SETREF, setNumber);
         }
     }
 }
@@ -2280,13 +2309,10 @@ void        RegexCompile::compileInterval(int32_t Init
     //        counterLoc   -->  Loop counter
     //               +1    -->  Input index (for breaking non-progressing loops)
     //                          (Only present if unbounded upper limit on loop)
-    int32_t   counterLoc = fRXPat->fFrameSize;
-    fRXPat->fFrameSize++;
-    if (fIntervalUpper < 0) {
-        fRXPat->fFrameSize++;
-    }
+    int32_t   dataSize = fIntervalUpper < 0 ? 2 : 1;
+    int32_t   counterLoc = allocateStackData(dataSize);
 
-    int32_t   op = URX_BUILD(InitOp, counterLoc);
+    int32_t   op = buildOp(InitOp, counterLoc);
     fRXPat->fCompiledPat->setElementAt(op, topOfBlock);
 
     // The second operand of CTR_INIT is the location following the end of the loop.
@@ -2294,7 +2320,7 @@ void        RegexCompile::compileInterval(int32_t Init
     //   compilation of something later on causes the code to grow and the target
     //   position to move.
     int32_t loopEnd = fRXPat->fCompiledPat->size();
-    op = URX_BUILD(URX_RELOC_OPRND, loopEnd);
+    op = buildOp(URX_RELOC_OPRND, loopEnd);
     fRXPat->fCompiledPat->setElementAt(op, topOfBlock+1);
 
     // Followed by the min and max counts.
@@ -2303,8 +2329,7 @@ void        RegexCompile::compileInterval(int32_t Init
 
     // Apend the CTR_LOOP op.  The operand is the location of the CTR_INIT op.
     //   Goes at end of the block being looped over, so just append to the code so far.
-    op = URX_BUILD(LoopOp, topOfBlock);
-    fRXPat->fCompiledPat->addElement(op, *fStatus);
+    appendOp(LoopOp, topOfBlock);
 
     if ((fIntervalLow & 0xff000000) != 0 ||
         (fIntervalUpper > 0 && (fIntervalUpper & 0xff000000) != 0)) {
@@ -2328,7 +2353,15 @@ UBool RegexCompile::compileInlineInterval() {
     int32_t   topOfBlock = blockTopLoc(FALSE);
     if (fIntervalUpper == 0) {
         // Pathological case.  Attempt no matches, as if the block doesn't exist.
+        // Discard the generated code for the block.
+        // If the block included parens, discard the info pertaining to them as well.
         fRXPat->fCompiledPat->setSize(topOfBlock);
+        if (fMatchOpenParen >= topOfBlock) {
+            fMatchOpenParen = -1;
+        }
+        if (fMatchCloseParen >= topOfBlock) {
+            fMatchCloseParen = -1;
+        }
         return TRUE;
     }
 
@@ -2349,7 +2382,7 @@ UBool RegexCompile::compileInlineInterval() {
     //
     int32_t endOfSequenceLoc = fRXPat->fCompiledPat->size()-1
                                 + fIntervalUpper + (fIntervalUpper-fIntervalLow);
-    int32_t saveOp = URX_BUILD(URX_STATE_SAVE, endOfSequenceLoc);
+    int32_t saveOp = buildOp(URX_STATE_SAVE, endOfSequenceLoc);
     if (fIntervalLow == 0) {
         insertOp(topOfBlock);
         fRXPat->fCompiledPat->setElementAt(saveOp, topOfBlock);
@@ -2362,13 +2395,10 @@ UBool RegexCompile::compileInlineInterval() {
     //    it was put there when it was originally encountered.
     int32_t i;
     for (i=1; i<fIntervalUpper; i++ ) {
-        if (i == fIntervalLow) {
-            fRXPat->fCompiledPat->addElement(saveOp, *fStatus);
+        if (i >= fIntervalLow) {
+            appendOp(saveOp);
         }
-        if (i > fIntervalLow) {
-            fRXPat->fCompiledPat->addElement(saveOp, *fStatus);
-        }
-        fRXPat->fCompiledPat->addElement(op, *fStatus);
+        appendOp(op);
     }
     return TRUE;
 }
@@ -3587,7 +3617,7 @@ void RegexCompile::stripNOPs() {
                 int32_t  operandAddress = URX_VAL(op);
                 U_ASSERT(operandAddress>=0 && operandAddress<deltas.size());
                 int32_t fixedOperandAddress = operandAddress - deltas.elementAti(operandAddress);
-                op = URX_BUILD(opType, fixedOperandAddress);
+                op = buildOp(opType, fixedOperandAddress);
                 fRXPat->fCompiledPat->setElementAt(op, dst);
                 dst++;
                 break;
@@ -3602,7 +3632,7 @@ void RegexCompile::stripNOPs() {
                     break;
                 }
                 where = fRXPat->fGroupMap->elementAti(where-1);
-                op    = URX_BUILD(opType, where);
+                op    = buildOp(opType, where);
                 fRXPat->fCompiledPat->setElementAt(op, dst);
                 dst++;
 
@@ -3954,7 +3984,7 @@ void RegexCompile::nextChar(RegexPatternChar &c) {
 //------------------------------------------------------------------------------
 //
 //  scanNamedChar
- //            Get a UChar32 from a \N{UNICODE CHARACTER NAME} in the pattern.
+//            Get a UChar32 from a \N{UNICODE CHARACTER NAME} in the pattern.
 //
 //             The scan position will be at the 'N'.  On return
 //             the scan position should be just after the '}'
