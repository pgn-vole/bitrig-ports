$OpenBSD: patch-src_gifio_c,v 1.4 2015/03/28 17:05:25 sthen Exp $

giflib 5.1+ compat

--- src/gifio.c.orig	Sat Mar 28 16:58:49 2015
+++ src/gifio.c	Sat Mar 28 16:59:29 2015
@@ -121,12 +121,12 @@ SavedImage       si;
 
         /* Read all the data, but use only the first image found */
     if (DGifSlurp(gif) != GIF_OK) {
-        DGifCloseFile(gif);
+        DGifCloseFile(gif, NULL);
         return (PIX *)ERROR_PTR("failed to read GIF data", procName, NULL);
     }
 
     if (gif->SavedImages == NULL) {
-        DGifCloseFile(gif);
+        DGifCloseFile(gif, NULL);
         return (PIX *)ERROR_PTR("no images found in GIF", procName, NULL);
     }
 
@@ -134,12 +134,12 @@ SavedImage       si;
     w = si.ImageDesc.Width;
     h = si.ImageDesc.Height;
     if (w <= 0 || h <= 0) {
-        DGifCloseFile(gif);
+        DGifCloseFile(gif, NULL);
         return (PIX *)ERROR_PTR("invalid image dimensions", procName, NULL);
     }
 
     if (si.RasterBits == NULL) {
-        DGifCloseFile(gif);
+        DGifCloseFile(gif, NULL);
         return (PIX *)ERROR_PTR("no raster data in GIF", procName, NULL);
     }
 
@@ -151,7 +151,7 @@ SavedImage       si;
         gif_cmap = gif->SColorMap;
     } else {
             /* don't know where to take cmap from */
-        DGifCloseFile(gif);
+        DGifCloseFile(gif, NULL);
         return (PIX *)ERROR_PTR("color map is missing", procName, NULL);
     }
 
@@ -175,7 +175,7 @@ SavedImage       si;
     }
 
     if ((pixd = pixCreate(w, h, d)) == NULL) {
-        DGifCloseFile(gif);
+        DGifCloseFile(gif, NULL);
         pixcmapDestroy(&cmap);
         return (PIX *)ERROR_PTR("failed to allocate pixd", procName, NULL);
     }
@@ -207,7 +207,7 @@ SavedImage       si;
         pixTransferAllData(pixd, &pixdi, 0, 0);
     }
 
-    DGifCloseFile(gif);
+    DGifCloseFile(gif, NULL);
     return pixd;
 }
 
@@ -356,14 +356,14 @@ GifByteType     *gif_line;
         != GIF_OK) {
         pixDestroy(&pixd);
         GifFreeMapObject(gif_cmap);
-        EGifCloseFile(gif);
+        EGifCloseFile(gif, NULL);
         return ERROR_INT("failed to write screen description", procName, 1);
     }
     GifFreeMapObject(gif_cmap); /* not needed after this point */
 
     if (EGifPutImageDesc(gif, 0, 0, w, h, FALSE, NULL) != GIF_OK) {
         pixDestroy(&pixd);
-        EGifCloseFile(gif);
+        EGifCloseFile(gif, NULL);
         return ERROR_INT("failed to image screen description", procName, 1);
     }
 
@@ -371,13 +371,13 @@ GifByteType     *gif_line;
     wpl = pixGetWpl(pixd);
     if (d != 1 && d != 2 && d != 4 && d != 8) {
         pixDestroy(&pixd);
-        EGifCloseFile(gif);
+        EGifCloseFile(gif, NULL);
         return ERROR_INT("image depth is not in {1, 2, 4, 8}", procName, 1);
     }
 
     if ((gif_line = (GifByteType *)CALLOC(sizeof(GifByteType), w)) == NULL) {
         pixDestroy(&pixd);
-        EGifCloseFile(gif);
+        EGifCloseFile(gif, NULL);
         return ERROR_INT("mem alloc fail for data line", procName, 1);
     }
 
@@ -406,7 +406,7 @@ GifByteType     *gif_line;
         if (EGifPutLine(gif, gif_line, w) != GIF_OK) {
             FREE(gif_line);
             pixDestroy(&pixd);
-            EGifCloseFile(gif);
+            EGifCloseFile(gif, NULL);
             return ERROR_INT("failed to write data line into GIF", procName, 1);
         }
     }
@@ -422,7 +422,7 @@ GifByteType     *gif_line;
 
     FREE(gif_line);
     pixDestroy(&pixd);
-    EGifCloseFile(gif);
+    EGifCloseFile(gif, NULL);
     return 0;
 }
 
